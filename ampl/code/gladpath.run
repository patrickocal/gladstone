#==============================================================================
#-----------parameters for storing (observable) path values
#==============================================================================
param CON 'observed consumption' {Regions, Sectors, PathTimes}
  default 1e+0; # in (OInf, OSup);
param INV_SEC 'observed investment' {Regions, Sectors, PathTimes}
  default 1e+0; # in (OInf, OSup);
param INV_SUM 'observed total investment' {Regions, Sectors, PathTimes}
  default 1e+0; # in (OInf, OSup); 
param MED_SUM 'observed total intermediate flows' {Regions, Sectors, PathTimes}
  default 1e+0; # in (OInf, OSup); 
param LAB 'observed labour' {Regions, Sectors, PathTimes}
  default 1e+0; # in (OInf, OSup);
param LAB_EXT 'observed laborforce participation' {Regions, Sectors, PathTimes}
  default 1e+0; # in (OInf, OSup);
param E_OUT 'observed Exp. output' {Regions, Sectors, PathTimes}
  default 1e+0; # in (OInf, OSup); 
param ADJ_COST_KAP 'observed adjustment costs of kapital'
  {Regions, Sectors, PathTimes} default 0; # in [0, OSup);
param MKT_CLR 'observed output' {Sectors, PathTimes}
  default 0; # in (-1e-4, 1e-4); 
param DUAL_KAP 'lagrange multiplier for kapital accumulation'
  {Regions, Sectors, PathTimes} default 1e+0; # in (-OSup, OSup);
param DUAL_MKT_CLR 'lagrange multiplier for market clearing constraint'
  {Sectors, PathTimes} default 1e+0;# in [0, OSup);
param GROWTH_KAP 'observed growth rate for kapital'
  {Regions, Sectors, PathTimes} default 5e-2; # in (-1, 1);
param GROWTH_OUT 'observed growth rate for output'
  {Regions, Sectors, PathTimes} default 5e-2; # in (-1, 1);
param EULER_INTEGRAND 'Euler error integrand'
  {Regions, Sectors, PathTimesClosure} default 1; # in (-OSup, OSup);
param EULER_RATIO 'Expected Euler ratio'
  {Regions, Sectors, PathTimes} default 1; # in (-1e+2, 1e+2);
param DOM 'actual path values for domestic output'
  {Regions, Sectors, PathTimes}
  default 100e-2;
param XPO 'actual path values for exports'
  {Regions, Sectors, PathTimes}
  default 100e-2;
param YMED_CSUM 'actual path values for sum over a row of intermediate imports'
  {Regions, Sectors, PathTimes}
  default 100e-2;
param CMED_SEC 'actual path values for intermediate input aggregator'
  {Regions, Sectors, PathTimes}
  default 100e-2;
param MPROD_FAC 'marginal product factor (just output in the Cobb--Doug case)'
  {r in Regions, i in Sectors, s in PathTimes}
  #= SCALE_OUT * A[i] * (A[i] / E_OUT[r, i, s]) ** (RHO_OUT / SCALE_OUT - 1);
  default 1;
param MPKK 'marginal product of kapital'
  {r in Regions, i in Sectors, s in PathTimes}
  #= MPROD_FAC[r, i, s] * SHR_KAP_OUT_CES[r, i] * KAP[r, i, s] ** (RHO_OUT );
  default 1;
param MPLL 'marginal product of labour'
  {r in Regions, i in Sectors, s in PathTimes}
  #= MPROD_FAC[r, i, s] * SHR_LAB_OUT_CES[r, i] * LAB[r, i, s] ** (RHO_OUT );
  default 1;
param MPMM 'marginal product of intermediate (the aggregator)'
  {r in Regions, i in Sectors, s in PathTimes}
  #= MPROD_FAC[r, i, s] * SHR_MED_OUT_CES[r, i]
  #  * CMED_SEC[r, i, s] ** (RHO_OUT );
  default 1;
param GVA 'gross value added'
  {r in Regions, i in Sectors, s in PathTimes}
  = MPKK[r, i, s] + MPLL[r, i, s];
param VERT_BAL 'vertical balance (should be zero)'
  {r in Regions, i in Sectors, s in PathTimes}
  = E_OUT[r, i, s] - GVA[r, i, s] - MPMM[r, i, s];
param AGG_OUT 'aggregate output per period'
  {r in Regions, s in PathTimes}
  = sum{i in Sectors} E_OUT[r, i, s];
param AGG_KAP 'aggregate kapital per period'
  {r in Regions, s in PathTimes}
  = sum{i in Sectors} KAP[r, i, s];
param AGG_CON 'aggregate consumption per period'
  {r in Regions, s in PathTimes}
  = sum{i in Sectors} CON[r, i, s];
param AGG_XPO 'aggregate exports per period'
  {r in Regions, s in PathTimes}
  = sum{i in Sectors} XPO[r, i, s];
param AGG_YMED_CSUM 'aggregate imports indirect alloc. (column sum) per period'
  {r in Regions, s in PathTimes}
  = sum{i in Sectors} YMED_CSUM[r, i, s];
#-----------solve the model along a given path
for {s in PathTimes}{
  display s, ctime();
  #if s = 6 then {
  #  let A['C'] := (1 - 10e-2) * A['C'];
  #  let KAP['GLD', 'C', s] := KAP['GLD', 'C', s] * 3 / 4;
  #  let RAW_MED_FLW['GLD', 'C', 'C'] := RAW_MED_FLW['GLD', 'C', 'C'] * 1 / 4;
  #  let RAW_MED_FLW['GLD', 'D', 'C'] := RAW_MED_FLW['GLD', 'D', 'C'] * 1 / 6;
  #  let RAW_XPO_JOUT['GLD', 'C'] := RAW_XPO_JOUT['GLD', 'C'] * 3 / 4;
  #};
#-----------update kapital (CJ call this the simulation step)
  fix {r in Regions, j in Sectors} kap[r, j, LInf] := KAP[r, j, s];
  let ALPHA := ALPHA * ALPHA_0;
  for {r in Regions, t in LookForwardClosure}{
    #let A_LAB[r, t] := - 271828182846e-11 ** - ((s + t) * SCALE_LAB);
  }
#  if s > 5 then 

  #if s = 5 then
  #  unfix {r in Regions, j in Sectors, t in LookForward}
  #    lab[r, j, t] := 31.4e-2;
#  if s <= 6 then option solver knitro; else option solver conopt;
#-----------display some parameter values:
  display PHI_ADJ['A'], A_LAB_EXT,
  NAIRE['GLD', 'O', 0], EXP_LAB_EXT['GLD', 'A', 0],
  LabSup, LSup, ALPHA_0, ALPHA, BETA, A['O'],
  SHR_CON['GLD', 'O'], SHR_LAB['GLD', 'O'],
  SHR_INV_CES['GLD', 'A', 'O'], DELTA['O'];
  display A_CON, A_INV, A_MED, A_VAL, A_LAB['GLD', 0],
  EPS_INV, EPS_MED, EPS_CON, EPS_OUT, EPS_LAB,
  RHO_INV,  RHO_MED,  RHO_CON, RHO_OUT, RHO_LAB,
  SCALE_CON, SCALE_INV, SCALE_MED, SCALE_OUT, SCALE_LAB,
  SCALE_CMED, SCALE_CINV;
#-----------in this algorithm other variables automatically get warm start
#  display E_out['GLD', 'O', LInf], con['GLD', 'O', LInf];
#-----------set and solve the plan for start time s
  objective pres_disc_val;
  let InstanceName := ("maiwar"
    & card(Regions) & "x" & card(Sectors)
    & "x" & card(LookForward) & "x");
  #write ("b" & InstanceName);
#-----------call the solver
  display s;
  solve;
  #solution (InstanceName & ".sol");
  display ctime(), _ampl_elapsed_time, _total_solve_time,
  _total_solve_system_time, _total_solve_user_time
  >> (InstanceName & "-results.txt");
#-----------display step values
  display E_out["GLD", "O", LInf], con["GLD", "O", LInf],
  inv_sec["GLD", "O", LInf], kap["GLD", "O", LInf],
  lab["GLD", "O", LInf], kap_transition["GLD", "O", LInf],
  market_clearing["O", LInf];
  for {r in Regions, i in Sectors}{
#-----------save actual path values of variables to parameter
    let CON[r, i, s] := con[r, i, LInf];
    let INV_SEC[r, i, s] := inv_sec[r, i, LInf];
    let INV_SUM[r, i, s] := sum{j in Sectors} inv[r, i, j, LInf];
    let MED_SUM[r, i, s] := sum{j in Sectors} med[r, i, j, LInf];
    let LAB[r, i, s] := lab[r, i, LInf];
    let LAB_EXT[r, i, s] := lab_ext[r, i, LInf];
    let E_OUT[r, i, s] := E_out[r, i, LInf];
    let DOM[r, i, s] := dom[r, i, LInf];
    let SHR_DOM[r, i, s] := shr_dom[r, i, LInf];
    let ADJ_COST_KAP[r, i, s] := adj_cost_kap[r, i, LInf];
    let KAP[r, i, s + 1] := kap[r, i, LInf + 1];
    let DUAL_KAP[r, i, s] := kap_transition[r, i, LInf];
    let XPO[r, i, s] := xpo[r, i, LInf];
    let YMED_CSUM[r, i, s] := sum{j in Sectors} ymed[r, i, j, LInf];
    let CMED_SEC[r, i, s] := cmed_sec_CES[r, i, LInf];
    let MPROD_FAC[r, i, s] := mprod_fac[r, i, LInf];
    let MPKK[r, i, s] := mpkk[r, i, LInf];
    let MPLL[r, i, s] := mpll[r, i, LInf];
    let MPMM[r, i, s] := mpmm[r, i, LInf];
    let 
  };
#    let TAIL_SHR_CON := (sum{r in Regions, i in Sectors} CON[r, i, s])
#      / (sum{r in Regions, i in Sectors} E_OUT[r, i, s]);
  #display E_OUT, CON, INV_SUM, MED_SUM, ADJ_COST_KAP, LAB, KAP;
  #display max {r in Regions, i in Sectors} DUAL_KAP[r, i, s];
  #display min {r in Regions, i in Sectors} DUAL_KAP[r, i, s];
  for {i in Sectors}{
#-----------save actual path values of market clearing to parameter
    let MKT_CLR[i, s] := sum{rr in Regions}(
      DOM[rr, i, s] 
      - CON[rr, i, s]
      - INV_SUM[rr, i, s] 
      - MED_SUM[rr, i, s]
      - ADJ_COST_KAP[rr, i, s]
      );
    let DUAL_MKT_CLR[i, s] := market_clearing[i, LInf];
  };
#-----------growth rate of capital as a parameter
  for {r in Regions, i in Sectors}{
    let GROWTH_KAP[r, i, s] := (KAP[r, i, s + 1] - KAP[r, i, s]) / KAP[r, i, s];
    if s > PInf then 
    let GROWTH_OUT[r, i, s] :=
      (E_OUT[r, i, s] - E_OUT[r, i, s - 1]) / E_OUT[r, i, s - 1];
   
#-----------Euler integrand for Cobb--Douglas production
    #let EULER_INTEGRAND[r, i, s] :=  DUAL_KAP[r, i, s] * (1 - DELTA[i]) 
    #  + DUAL_MKT_CLR[i, s] * (
    #    SHR_KAP_OUT[i] * (KAP[r, i, s] / LAB[r, i, s]) ** (SHR_KAP_OUT[i] - 1)
    #    - PHI_ADJ[i] * (2 * GROWTH_KAP[r, i, s] + GROWTH_KAP[r, i, s] ** 2)
    #  );
#-----------Euler integrand for CES production
    let EULER_INTEGRAND[r, i, s] := DUAL_KAP[r, i, s] * (1 - DELTA[i]) 
      + DUAL_MKT_CLR[i, s] * (
        SHR_KAP_OUT_CES[r, i] * LAB_EXT[r, i, s] ** RHO_OUT
          * KAP[r, i, s] ** (RHO_OUT - 1)
        * SCALE_OUT * A[i] * SHR_DOM[r, i, s]
          * (DOM[r, i, s] / (A[i] * SHR_DOM[r, i, s]))
            ** (1 - RHO_OUT / SCALE_OUT)
        - PHI_ADJ[i] * (2 * GROWTH_KAP[r, i, s] + GROWTH_KAP[r, i, s] ** 2)
      );
    if s > PInf then 
    let EULER_RATIO[r, i, s] 
        := BETA * EULER_INTEGRAND[r, i, s] / DUAL_KAP[r, i, s - 1];
  };

   write table res;
   write table aggres;
#  write table kp;
  display GROWTH_KAP, GROWTH_OUT, EULER_INTEGRAND, EULER_RATIO,
    min{r in Regions, i in Sectors} E_OUT[r, i, s],
    max{r in Regions, i in Sectors} E_OUT[r, i, s],
    min{r in Regions, i in Sectors} CON[r, i, s],
    max{r in Regions, i in Sectors} CON[r, i, s],
    min{r in Regions, i in Sectors} INV_SUM[r, i, s],
    max{r in Regions, i in Sectors} INV_SUM[r, i, s],
    min{r in Regions, i in Sectors} MED_SUM[r, i, s],
    max{r in Regions, i in Sectors} MED_SUM[r, i, s],
    max{r in Regions, i in Sectors} ADJ_COST_KAP[r, i, s],
    max{i in Sectors} abs(MKT_CLR[i, s]),
    min{i in Sectors} DUAL_MKT_CLR[i, s],
    max{i in Sectors} DUAL_MKT_CLR[i, s],
    min{r in Regions, i in Sectors} LAB[r, i, s],
    max{r in Regions, i in Sectors} LAB[r, i, s],
    min{r in Regions, i in Sectors} LAB_EXT[r, i, s],
    max{r in Regions, i in Sectors} LAB_EXT[r, i, s],
    min{r in Regions, i in Sectors} KAP[r, i, s + 1],
    max{r in Regions, i in Sectors} KAP[r, i, s + 1],
    min{r in Regions, i in Sectors} GROWTH_KAP[r, i, s],
    max{r in Regions, i in Sectors} GROWTH_KAP[r, i, s],
    min{r in Regions, i in Sectors} DUAL_KAP[r, i, s],
    min{r in Regions, i in Sectors} XPO[r, i, s],
    max{r in Regions, i in Sectors} XPO[r, i, s],
    utility, tail_val, pres_disc_val,
    (sum{r in Regions, i in Sectors} con[r, i, LInf])
      / (sum{r in Regions, i in Sectors} E_out[r, i, LInf]),
    KAP['GLD', 'O', s] / E_OUT['GLD', 'O', s],
    s, _ampl_elapsed_time, _total_solve_time, ctime();
#  for {r in Regions, i in Sectors}{
#  if s > PInf then display EULER_RATIO[r, i, s] - EULER_RATIO[r, i, s - 1];
#  };
};


#display KAP;
