
#-----------solve the model along a given path
for {s in PathTimes}{
  display s, ctime();
#-----------update kapital (CJ call this the simulation step)
  fix {r in Regions, j in Sectors} kap[r, j, LInf] := KAP[r, j, s];
  if s > PInf then
  let ALPHA := ALPHA * ALPHA_0;
  for {r in Regions, t in LookForwardClosure}{
    #let A_LAB[r, t] := - 271828182846e-11 ** - ((s + t) * SCALE_LAB);
  }
  #if s = 5 then
  #  unfix {r in Regions, j in Sectors, t in LookForward}
  #    lab[r, j, t] := 31.4e-2;
  #if s = 20 then
  #  let A['A'] := (1 - 33e-2) * A['A'];
  ;
#  if s <= 6 then option solver knitro; else option solver conopt;
#-----------display some parameter values:
  display PHI_ADJ['A'], A_LAB_EXT,
  NAIRE['SEQ', 'PbSc', 0], EXP_LAB_EXT['SEQ', 'A', 0],
  LabSup, LSup, ALPHA_0, ALPHA, BETA, A['PbSc'],
  SHR_CON['SEQ', 'PbSc'], SHR_LAB['SEQ', 'PbSc'],
  SHR_INV_CES['SEQ', 'A', 'PbSc'], DELTA['PbSc'];
  display A_CON, A_INV, A_MED, A_VAL, A_LAB['SEQ', 0],
  EPS_INV, EPS_MED, EPS_CON, EPS_OUT, EPS_LAB,
  RHO_INV,  RHO_MED,  RHO_CON, RHO_OUT, RHO_LAB,
  SCALE_CON, SCALE_INV, SCALE_MED, SCALE_OUT, SCALE_LAB,
  SCALE_CMED, SCALE_CINV;
#-----------in this algorithm other variables automatically get warm start
  display E_out['SEQ', 'PbSc', LInf], con['SEQ', 'PbSc', LInf];
#-----------set and solve the plan for start time s
  objective pres_disc_val;
  let InstanceName := ("maiwar"
    & card(Regions) & "x" & card(Sectors)
    & "x" & card(LookForward) & "x");
  #write ("b" & InstanceName);
#-----------call the solver
  display s;
  solve;
  #solution (InstanceName & ".sol");
  display ctime(), _ampl_elapsed_time, _total_solve_time,
  _total_solve_system_time, _total_solve_user_time
  >> (InstanceName & "-results.txt");
#-----------display step values
  display E_out["SEQ", "PbSc", LInf], con["SEQ", "PbSc", LInf],
  inv_sec["SEQ", "PbSc", LInf], kap["SEQ", "PbSc", LInf],
  lab["SEQ", "PbSc", LInf], kap_transition["SEQ", "PbSc", LInf],
  market_clearing["PbSc", LInf];
  for {r in Regions, i in Sectors}{
#-----------save actual path values of variables to parameter
    let CON[r, i, s] := con[r, i, LInf];
    let INV_SEC[r, i, s] := inv_sec[r, i, LInf];
    let INV_SUM[r, i, s] := sum{j in Sectors} inv[r, i, j, LInf];
    let MED_SUM[r, i, s] := sum{j in Sectors} med[r, i, j, LInf];
    let LAB[r, i, s] := lab[r, i, LInf];
    let LAB_EXT[r, i, s] := lab_ext[r, i, LInf];
    let E_OUT[r, i, s] := E_out[r, i, LInf];
    let DOM[r, i, s] := dom[r, i, LInf];
    let SHR_DOM[r, i, s] := shr_dom[r, i, LInf];
    let ADJ_COST_KAP[r, i, s] := adj_cost_kap[r, i, LInf];
    let KAP[r, i, s + 1] := kap[r, i, LInf + 1];
    let DUAL_KAP[r, i, s] := kap_transition[r, i, LInf]
  };
#    let TAIL_SHR_CON := (sum{r in Regions, i in Sectors} CON[r, i, s])
#      / (sum{r in Regions, i in Sectors} E_OUT[r, i, s]);
  #display E_OUT, CON, INV_SUM, MED_SUM, ADJ_COST_KAP, LAB, KAP;
  #display max {r in Regions, i in Sectors} DUAL_KAP[r, i, s];
  #display min {r in Regions, i in Sectors} DUAL_KAP[r, i, s];
  for {i in Sectors}{
#-----------save actual path values of market clearing to parameter
    let MKT_CLR[i, s] := sum{rr in Regions}(
      DOM[rr, i, s] 
      - CON[rr, i, s]
      - INV_SUM[rr, i, s] 
      - MED_SUM[rr, i, s]
      - ADJ_COST_KAP[rr, i, s]
      );
    let DUAL_MKT_CLR[i, s] := market_clearing[i, LInf];
  };
#-----------growth rate of capital as a parameter
  for {r in Regions, i in Sectors}{
    let GROWTH_KAP[r, i, s] := (KAP[r, i, s + 1] - KAP[r, i, s]) / KAP[r, i, s];
    if s > PInf then 
    let GROWTH_OUT[r, i, s] :=
      (E_OUT[r, i, s] - E_OUT[r, i, s - 1]) / E_OUT[r, i, s - 1];
   
#-----------Euler integrand for Cobb--Douglas production
    #let EULER_INTEGRAND[r, i, s] :=  DUAL_KAP[r, i, s] * (1 - DELTA[i]) 
    #  + DUAL_MKT_CLR[i, s] * (
    #    SHR_KAP_OUT[i] * (KAP[r, i, s] / LAB[r, i, s]) ** (SHR_KAP_OUT[i] - 1)
    #    - PHI_ADJ[i] * (2 * GROWTH_KAP[r, i, s] + GROWTH_KAP[r, i, s] ** 2)
    #  );
#-----------Euler integrand for CES production
    let EULER_INTEGRAND[r, i, s] := DUAL_KAP[r, i, s] * (1 - DELTA[i]) 
      + DUAL_MKT_CLR[i, s] * (
        SHR_KAP_OUT_CES[i] * LAB_EXT[r, i, s] ** RHO_OUT
          * KAP[r, i, s] ** (RHO_OUT - 1)
        * SCALE_OUT * A[i] * SHR_DOM[r, i, s]
          * (DOM[r, i, s] / (A[i] * SHR_DOM[r, i, s]))
            ** (1 - RHO_OUT / SCALE_OUT)
        - PHI_ADJ[i] * (2 * GROWTH_KAP[r, i, s] + GROWTH_KAP[r, i, s] ** 2)
      );
    if s > PInf then 
    let EULER_RATIO[r, i, s] 
        := BETA * EULER_INTEGRAND[r, i, s] / DUAL_KAP[r, i, s - 1];
  };
  display GROWTH_KAP, GROWTH_OUT, EULER_INTEGRAND, EULER_RATIO,
    min{r in Regions, i in Sectors} E_OUT[r, i, s],
    max{r in Regions, i in Sectors} E_OUT[r, i, s],
    min{r in Regions, i in Sectors} CON[r, i, s],
    max{r in Regions, i in Sectors} CON[r, i, s],
    min{r in Regions, i in Sectors} INV_SUM[r, i, s],
    max{r in Regions, i in Sectors} INV_SUM[r, i, s],
    min{r in Regions, i in Sectors} MED_SUM[r, i, s],
    max{r in Regions, i in Sectors} MED_SUM[r, i, s],
    max{r in Regions, i in Sectors} ADJ_COST_KAP[r, i, s],
    max{i in Sectors} abs(MKT_CLR[i, s]),
    min{i in Sectors} DUAL_MKT_CLR[i, s],
    max{i in Sectors} DUAL_MKT_CLR[i, s],
    min{r in Regions, i in Sectors} LAB[r, i, s],
    max{r in Regions, i in Sectors} LAB[r, i, s],
    min{r in Regions, i in Sectors} LAB_EXT[r, i, s],
    max{r in Regions, i in Sectors} LAB_EXT[r, i, s],
    min{r in Regions, i in Sectors} KAP[r, i, s + 1],
    max{r in Regions, i in Sectors} KAP[r, i, s + 1],
    min{r in Regions, i in Sectors} GROWTH_KAP[r, i, s],
    max{r in Regions, i in Sectors} GROWTH_KAP[r, i, s],
    min{r in Regions, i in Sectors} DUAL_KAP[r, i, s],
    utility, tail_val, pres_disc_val,
    (sum{r in Regions, i in Sectors} con[r, i, LInf])
      / (sum{r in Regions, i in Sectors} E_out[r, i, LInf]),
    KAP['SEQ', 'PbSc', s] / E_OUT['SEQ', 'PbSc', s],
    s, _ampl_elapsed_time, _total_solve_time, ctime();
#  for {r in Regions, i in Sectors}{
#  if s > PInf then display EULER_RATIO[r, i, s] - EULER_RATIO[r, i, s - 1];
#  };
};


#display KAP;
